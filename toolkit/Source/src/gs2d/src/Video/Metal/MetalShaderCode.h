/* This file has been generated by the ShaderToCHeader tool. Do not edit! */

#ifndef METAL_SHADER_CODE_H_
#define METAL_SHADER_CODE_H_

#include <string>

/* Shaders included in this file:
Metal/default-sprite-add.fs               ->     default_sprite_add_fs
Metal/default-sprite-fast.vs              ->     default_sprite_fast_vs
Metal/default-sprite-highlight.fs         ->     default_sprite_highlight_fs
Metal/default-sprite-modulate.fs          ->     default_sprite_modulate_fs
Metal/default-sprite-solid-color-add.fs   ->     default_sprite_solid_color_add_fs
Metal/default-sprite-solid-color-modulate.fs->     default_sprite_solid_color_modulate_fs
Metal/default-sprite-solid-color.fs       ->     default_sprite_solid_color_fs
Metal/default-sprite.fs                   ->     default_sprite_fs
Metal/default-sprite.vs                   ->     default_sprite_vs
*/

namespace gs2d_shaders {

const std::string default_sprite_add_fs = 
"fragment float4 fragment_main(\n" \
"	Vertex inVertex [[stage_in]],\n" \
"	constant Uniforms& uniforms [[buffer(1)]],\n" \
"	texture2d<half> diffuse [[ texture(0) ]],\n" \
"	texture2d<half> secondary [[ texture(1) ]])\n" \
"{\n" \
"	constexpr sampler colorSampler(mip_filter::linear, mag_filter::linear, min_filter::linear, address::clamp_to_edge);\n" \
"	half4 colorSample = diffuse.sample(colorSampler, inVertex.texCoord.xy);\n" \
"	half4 addSample = secondary.sample(colorSampler, inVertex.texCoord.xy);\n" \
"\n" \
"	return (float4(colorSample) * uniforms.u[COLOR]) + float4(addSample.x, addSample.y, addSample.z, 0.0f);\n" \
"}\n" \
"\n" \
"\n";

const std::string default_sprite_fast_vs = 
"#include <metal_stdlib>\n" \
"\n" \
"using namespace metal;\n" \
"\n" \
"struct Vertex\n" \
"{\n" \
"	float4 position [[position]];\n" \
"	float4 texCoord;\n" \
"	float4 normal;\n" \
"};\n" \
"\n" \
"typedef float2 vec2;\n" \
"typedef float3 vec3;\n" \
"typedef float4 vec4;\n" \
"\n" \
"#define SIZE_ORIGIN 0\n" \
"#define SPRITEPOS_VIRTUALTARGETRESOLUTION 1\n" \
"#define COLOR 2\n" \
"#define RECTPOS_RECTSIZE 3\n" \
"\n" \
"struct Uniforms\n" \
"{\n" \
"	vec4 u[4];\n" \
"};\n" \
"\n" \
"vertex Vertex vertex_main(\n" \
"	const device Vertex* vertices [[buffer(0)]],\n" \
"	constant Uniforms& uniforms [[buffer(1)]],\n" \
"	uint vid [[vertex_id]])\n" \
"{\n" \
"	Vertex vout = vertices[vid];\n" \
"	vec4 vertexPos = vout.position;\n" \
"\n" \
"	vec2 size   = vec2(uniforms.u[SIZE_ORIGIN].x, uniforms.u[SIZE_ORIGIN].y);\n" \
"	vec2 origin = vec2(uniforms.u[SIZE_ORIGIN].z, uniforms.u[SIZE_ORIGIN].w);\n" \
"\n" \
"	vec2 spritePos = vec2(uniforms.u[SPRITEPOS_VIRTUALTARGETRESOLUTION].x, uniforms.u[SPRITEPOS_VIRTUALTARGETRESOLUTION].y);\n" \
"	vec2 virtualTargetResolution = vec2(uniforms.u[SPRITEPOS_VIRTUALTARGETRESOLUTION].z, uniforms.u[SPRITEPOS_VIRTUALTARGETRESOLUTION].w);\n" \
"\n" \
"	vec2 rectPos  = vec2(uniforms.u[RECTPOS_RECTSIZE].x, uniforms.u[RECTPOS_RECTSIZE].y);\n" \
"	vec2 rectSize = vec2(uniforms.u[RECTPOS_RECTSIZE].z, uniforms.u[RECTPOS_RECTSIZE].w);\n" \
"\n" \
"	// scale to size and flip y-axis\n" \
"	size.y *= -1.0;\n" \
"	vertexPos = vertexPos * vec4(size.x, size.y, 1.0, 1.0);\n" \
"\n" \
"	// adjust origin\n" \
"	vertexPos = vertexPos - vec4(origin * size, 0.0, 0.0);\n" \
"\n" \
"	// translate\n" \
"	vertexPos = vertexPos + vec4(spritePos.x,-spritePos.y, 0.0, 0.0);\n" \
"\n" \
"	// adjust axis to traditional 2D\n" \
"	vec2 halfScreenSize = virtualTargetResolution / 2.0;\n" \
"	vertexPos = vertexPos + vec4(-halfScreenSize.x, halfScreenSize.y, 0.0, 0.0);\n" \
"\n" \
"	// scale to match fixed virtual\n" \
"	vertexPos.x /= halfScreenSize.x;\n" \
"	vertexPos.y /= halfScreenSize.y;\n" \
"\n" \
"	vout.position = vertexPos;\n" \
"	vout.texCoord = vec4((vout.texCoord.xy * rectSize) + rectPos, 1.0f, 1.0f);\n" \
"	return vout;\n" \
"}\n" \
"\n" \
"\n";

const std::string default_sprite_highlight_fs = 
"fragment float4 fragment_main(\n" \
"	Vertex inVertex [[stage_in]],\n" \
"	constant Uniforms& uniforms [[buffer(1)]],\n" \
"	texture2d<half> diffuse [[ texture(0) ]])\n" \
"{\n" \
"	constexpr sampler colorSampler(mip_filter::linear, mag_filter::linear, min_filter::linear, address::clamp_to_edge);\n" \
"	half4 colorSample = diffuse.sample(colorSampler, inVertex.texCoord.xy);\n" \
"\n" \
"	return float4(colorSample) * uniforms.highlight;\n" \
"}\n" \
"\n" \
"\n";

const std::string default_sprite_modulate_fs = 
"fragment float4 fragment_main(\n" \
"	Vertex inVertex [[stage_in]],\n" \
"	constant Uniforms& uniforms [[buffer(1)]],\n" \
"	texture2d<half> diffuse [[ texture(0) ]],\n" \
"	texture2d<half> secondary [[ texture(1) ]])\n" \
"{\n" \
"	constexpr sampler colorSampler(mip_filter::linear, mag_filter::linear, min_filter::linear, address::clamp_to_edge);\n" \
"	half4 colorSample = diffuse.sample(colorSampler, inVertex.texCoord.xy);\n" \
"	half4 addSample = secondary.sample(colorSampler, inVertex.texCoord.xy);\n" \
"\n" \
"	return float4(colorSample) * float4(addSample) * uniforms.u[COLOR];\n" \
"}\n" \
"\n" \
"\n";

const std::string default_sprite_solid_color_add_fs = 
"fragment float4 fragment_main(\n" \
"	Vertex inVertex [[stage_in]],\n" \
"	constant Uniforms& uniforms [[buffer(1)]],\n" \
"	texture2d<half> diffuse [[ texture(0) ]],\n" \
"	texture2d<half> secondary [[ texture(1) ]])\n" \
"{\n" \
"	constexpr sampler colorSampler(mip_filter::linear, mag_filter::linear, min_filter::linear, address::clamp_to_edge);\n" \
"	half4 colorSample = diffuse.sample(colorSampler, inVertex.texCoord.xy);\n" \
"	half4 addSample = secondary.sample(colorSampler, inVertex.texCoord.xy);\n" \
"\n" \
"	vec4 blendedColor = (vec4(colorSample) * uniforms.u[COLOR]) + float4(addSample.x, addSample.y, addSample.z, 0.0f);\n" \
"	return mix(blendedColor, vec4(uniforms.solidColor.x, uniforms.solidColor.y, uniforms.solidColor.z, blendedColor.w), uniforms.solidColor.w);\n" \
"}\n" \
"\n" \
"\n";

const std::string default_sprite_solid_color_modulate_fs = 
"fragment float4 fragment_main(\n" \
"	Vertex inVertex [[stage_in]],\n" \
"	constant Uniforms& uniforms [[buffer(1)]],\n" \
"	texture2d<half> diffuse [[ texture(0) ]],\n" \
"	texture2d<half> secondary [[ texture(1) ]])\n" \
"{\n" \
"	constexpr sampler colorSampler(mip_filter::linear, mag_filter::linear, min_filter::linear, address::clamp_to_edge);\n" \
"	half4 colorSample = diffuse.sample(colorSampler, inVertex.texCoord.xy);\n" \
"	half4 modSample = secondary.sample(colorSampler, inVertex.texCoord.xy);\n" \
"\n" \
"	vec4 blendedColor = vec4(colorSample) * uniforms.u[COLOR] * float4(modSample);\n" \
"	return mix(blendedColor, vec4(uniforms.solidColor.x, uniforms.solidColor.y, uniforms.solidColor.z, blendedColor.w), uniforms.solidColor.w);\n" \
"}\n" \
"\n" \
"\n";

const std::string default_sprite_solid_color_fs = 
"fragment float4 fragment_main(\n" \
"	Vertex inVertex [[stage_in]],\n" \
"	constant Uniforms& uniforms [[buffer(1)]],\n" \
"	texture2d<half> diffuse [[ texture(0) ]])\n" \
"{\n" \
"	constexpr sampler colorSampler(mip_filter::linear, mag_filter::linear, min_filter::linear, address::clamp_to_edge);\n" \
"	half4 colorSample = diffuse.sample(colorSampler, inVertex.texCoord.xy);\n" \
"\n" \
"	vec4 blendedColor = vec4(colorSample) * uniforms.highlight;\n" \
"	return mix(blendedColor, vec4(uniforms.solidColor.x, uniforms.solidColor.y, uniforms.solidColor.z, blendedColor.w), uniforms.solidColor.w);\n" \
"}\n" \
"\n" \
"\n";

const std::string default_sprite_fs = 
"fragment float4 fragment_main(\n" \
"	Vertex inVertex [[stage_in]],\n" \
"	constant Uniforms& uniforms [[buffer(1)]],\n" \
"	texture2d<half> diffuse [[ texture(0) ]])\n" \
"{\n" \
"	constexpr sampler colorSampler(mip_filter::linear, mag_filter::linear, min_filter::linear, address::clamp_to_edge);\n" \
"	half4 colorSample = diffuse.sample(colorSampler, inVertex.texCoord.xy);\n" \
"\n" \
"	return float4(colorSample) * uniforms.u[COLOR];\n" \
"}\n" \
"\n" \
"\n";

const std::string default_sprite_vs = 
"#include <metal_stdlib>\n" \
"\n" \
"using namespace metal;\n" \
"\n" \
"struct Vertex\n" \
"{\n" \
"	float4 position [[position]];\n" \
"	float4 texCoord;\n" \
"	float4 normal;\n" \
"};\n" \
"\n" \
"typedef float2 vec2;\n" \
"typedef float3 vec3;\n" \
"typedef float4 vec4;\n" \
"\n" \
"#define SIZE_ORIGIN 0\n" \
"#define SPRITEPOS_VIRTUALTARGETRESOLUTION 1\n" \
"#define COLOR 2\n" \
"#define FLIPADD_FLIPMUL 3\n" \
"#define RECTPOS_RECTSIZE 4\n" \
"#define ANGLE_PARALLAXINTENSITY_ZPOS 5\n" \
"\n" \
"struct Uniforms\n" \
"{\n" \
"	vec4 u[6];\n" \
"	vec4 highlight;\n" \
"	vec4 solidColor;\n" \
"};\n" \
"\n" \
"vertex Vertex vertex_main(\n" \
"	const device Vertex* vertices [[buffer(0)]],\n" \
"	constant Uniforms& uniforms [[buffer(1)]],\n" \
"	uint vid [[vertex_id]])\n" \
"{\n" \
"	Vertex vout = vertices[vid];\n" \
"	vec4 vertexPos = vout.position;\n" \
"\n" \
"	vec2 size   = vec2(uniforms.u[SIZE_ORIGIN].x, uniforms.u[SIZE_ORIGIN].y);\n" \
"	vec2 origin = vec2(uniforms.u[SIZE_ORIGIN].z, uniforms.u[SIZE_ORIGIN].w);\n" \
"\n" \
"	vec2 spritePos = vec2(uniforms.u[SPRITEPOS_VIRTUALTARGETRESOLUTION].x, uniforms.u[SPRITEPOS_VIRTUALTARGETRESOLUTION].y);\n" \
"	vec2 virtualTargetResolution = vec2(uniforms.u[SPRITEPOS_VIRTUALTARGETRESOLUTION].z, uniforms.u[SPRITEPOS_VIRTUALTARGETRESOLUTION].w);\n" \
"\n" \
"	vec2 flipAdd = vec2(uniforms.u[FLIPADD_FLIPMUL].x, uniforms.u[FLIPADD_FLIPMUL].y);\n" \
"	vec2 flipMul = vec2(uniforms.u[FLIPADD_FLIPMUL].z, uniforms.u[FLIPADD_FLIPMUL].w);\n" \
"\n" \
"	vec2 rectPos  = vec2(uniforms.u[RECTPOS_RECTSIZE].x, uniforms.u[RECTPOS_RECTSIZE].y);\n" \
"	vec2 rectSize = vec2(uniforms.u[RECTPOS_RECTSIZE].z, uniforms.u[RECTPOS_RECTSIZE].w);\n" \
"\n" \
"	float angle = uniforms.u[ANGLE_PARALLAXINTENSITY_ZPOS].x;\n" \
"	float parallaxIntensity = uniforms.u[ANGLE_PARALLAXINTENSITY_ZPOS].y;\n" \
"	float zPos = uniforms.u[ANGLE_PARALLAXINTENSITY_ZPOS].z;\n" \
"\n" \
"	// apply flip\n" \
"	vertexPos = vertexPos * vec4(flipMul.x, flipMul.y, 1.0f, 1.0f) + vec4(flipAdd.x, flipAdd.y, 0.0f, 0.0f);\n" \
"\n" \
"	// scale to size and flip y-axis\n" \
"	size.y *= -1.0f;\n" \
"	vertexPos = vertexPos * vec4(size.x, size.y, 1.0f, 1.0f);\n" \
"\n" \
"	// adjust origin\n" \
"	vertexPos = vertexPos - vec4(origin * size, 0.0f, 0.0f);\n" \
"\n" \
"	// rotate\n" \
"	vertexPos = vec4(\n" \
"		vertexPos.x * cos(angle) - vertexPos.y * sin(angle),\n" \
"		vertexPos.x * sin(angle) + vertexPos.y * cos(angle),\n" \
"		vertexPos.z,\n" \
"		vertexPos.w);\n" \
"\n" \
"	// translate\n" \
"	vertexPos = vertexPos + vec4(spritePos.x,-spritePos.y, 0.0f, 0.0f);\n" \
"\n" \
"	// compute parallax offset\n" \
"	vec2 halfScreenSize = virtualTargetResolution / 2.0f;\n" \
"	vec2 parallaxOffset = ((vertexPos.xy + vec2(-halfScreenSize.x, halfScreenSize.y)) / virtualTargetResolution.y) * parallaxIntensity * zPos;\n" \
"	vertexPos = vertexPos + vec4(parallaxOffset, 0.0f, 0.0f);\n" \
"\n" \
"	// adjust axis to traditional 2D\n" \
"	vertexPos = vertexPos + vec4(-halfScreenSize.x, halfScreenSize.y, 0.0f, 0.0f);\n" \
"\n" \
"	// scale to match fixed virtual\n" \
"	vertexPos.x /= halfScreenSize.x;\n" \
"	vertexPos.y /= halfScreenSize.y;\n" \
"\n" \
"	vout.position = vertexPos;\n" \
"	vout.texCoord = vec4((vout.texCoord.xy * rectSize) + rectPos, 1.0f, 1.0f);\n" \
"\n" \
"	return vout;\n" \
"}\n" \
"\n" \
"\n";


}

#endif
